项目中常常用的和创建的skills都有哪些？(比如我平常开发用的git提交规范，mcp调度，并行开发从一个文件夹📂下领任务做完标记，)，市面主流不同领域开发的有哪些？主要是有体系流程化的，比如stitch➕ai studio ➕cursor➕supabase ➕cecel这样构建一个workflow的，以及Claudecode官方的有哪些，先罗列出来给出简单介绍，不详细讨论
已思考 14s

下面给你一份「项目里常用/会自己搭建的 skills（能力块）」清单 + 「市面主流各领域的流程化体系」+「Claude Code 官方常见组件」——只罗列+一句话介绍，不展开😈

1) 项目里最常见的“工程化 skills”（通用底座）
代码与协作

Git 提交规范：Conventional Commits（feat/fix/refactor/chore...）统一可读、可生成变更日志

分支策略：Trunk-based / GitFlow / Release branch（决定并行开发怎么合并、怎么发版）

PR 规范 + Code Review：模板、检查项、owner 规则（把“拍脑袋”变“流程”）

任务领取/状态流转：看板（Todo/Doing/Blocked/Done）+ 文件夹任务制（你说的📂领任务+标记其实就是轻量看板）

质量与一致性

Lint/Format：ESLint/Prettier/ruff/gofmt（把风格争吵扼杀在摇篮里）

测试金字塔：Unit / Integration / E2E（把“能跑”变“可维护能改”）

静态检查/类型系统：TypeScript / mypy / go vet（让 bug 更早死）

CI Pipeline：自动跑测试、lint、build、security scan（不给人肉背锅机会）

交付与运维

版本与发版：SemVer + Changesets / Semantic Release（自动出 changelog、自动发包）

环境管理：dev/staging/prod + 配置隔离（别把测试 key 推到线上🙏）

Feature Flags：灰度/回滚开关（救命用）

观测性：logging/metrics/tracing + Sentry（出事能定位，别靠玄学）

2) AI 时代新增的“workflow skills”（你提到的 MCP/调度/并行开发属于这里）
Agent / 工具编排

MCP（Model Context Protocol）工具接入：让 AI 以“工具调用”方式连数据库/代码库/文档（你说的 mcp 调度属于这个范畴）

多步工具链（tool chaining / max steps）：模型连续多次调用工具完成任务（Vercel AI SDK 这类会强调多步 tool calls）

并行任务拆解：把需求拆成多个小任务让 agent 并行做（产出后再人类合并审查）

上下文管理：规则/记忆/检索（避免“每次都失忆”）

规则化与可控性

IDE 规则系统（Cursor Rules）：项目级 .cursor/rules 约束生成代码风格、目录结构、禁忌操作

Hook / 自动化钩子：在关键事件触发脚本或提示词（Claude Code 这块是官方强项）

评测（Evals）：对 agent 输出做回归测试（避免“今天聪明明天发疯”）

3) 不同领域“主流流程化体系”速览（按赛道）
Web/全栈（独立开发最常见）

设计→代码→后端→部署一条龙：Stitch → Figma → AI Studio →（Cursor 改）→ Supabase（Auth/DB）→ Vercel（部署）
典型卖点：从 UI 到可跑 MVP 快速闭环

前端组件体系：Design System + Storybook + 自动生成组件/文档

后端体系：API 设计（OpenAPI）+ DB migration + 权限/审计 + 观测

移动端（iOS/Android）

CI/CD：Fastlane + TestFlight/Play Console 自动发布

崩溃监控：Crashlytics/Sentry

版本灰度：分渠道/分批次 rollout

数据/ML（MLOps）

数据管道：ETL/ELT + 数据质量校验

训练/评测/上线：实验追踪（MLflow 等）+ 模型注册 + A/B

监控：漂移检测、线上指标回流

DevOps/平台工程

IaC：Terraform/Pulumi（环境可复制）

GitOps：用 Git 管理发布（ArgoCD/Flux）

SRE 流程：SLO/SLI、事故复盘、变更管理

企业协作/流程管理

需求→开发→测试→发布：Jira/Linear + PR 模板 + release note 自动化

知识库：ADR（架构决策记录）+ 文档规范

4) 你点名的「Claude Code 官方常见组件」（只列关键词）

Hooks（钩子）：在生命周期事件自动执行命令/提示词，还能接 MCP 工具钩子

MCP 集成：把外部系统变成可调用工具（常用于 repo/文档/DB/issue tracker）

命令/工作流编排：用预设命令把“做事步骤”固化（减少随缘发挥）

配置/规则/记忆（Memory）：让它更稳定地遵循项目约定（和 Cursor Rules 同类思路，只是载体不同）

想要「Claude Code 官方还有哪些具体命令/目录结构/配置文件长啥样」，我也能按官方文档再给一页速查表（同样不展开）😏

如果你下一句告诉我：你现在主要做 Web 全栈 / 移动 / 数据 / 工程平台 里哪一个，我可以把上面清单按你的赛道「精简成一套默认 workflow 模板」（比如：任务📂→并行 agent→PR→CI→发版→监控）🧩

在做web全栈，做了小程序，网页变贪吃蛇和对话系统，前后端的，还有对应的后台管理界面，最近就是在用上述说的workflow✌︎' ֊'，stitch生成原型图，ai studio 给前端代码，cursor和supabase打通后端和数据库，最后测试，vercel部署，维护分支继续

行，你这套已经很“工业化”了😈 现在差的不是工具，而是把流程固化成可复制的体系。给你一份 Web 全栈（小程序+网页+后台） 的「技能块 + 流程骨架」清单，照着补齐就能越做越顺 ✌️

你这条链路的“标准 Workflow 骨架”

需求/原型：Stitch（原型）→ 定义页面/状态/接口草稿

前端生成：AI Studio（初版 UI）→ Cursor（收敛成项目规范）

后端&DB：Supabase（Auth/DB/Storage/Edge/Functions）+ RLS

联调：前后端 contract 固化（OpenAPI / tRPC / typed client）

测试：关键路径 E2E + API 集成 + 最少单测兜底

部署：Vercel（Preview→Prod）

维护：分支策略 + 版本发布 + 观测报警 + 迭代

你项目里最该“建起来并长期复用”的 skills（建议优先级从高到低）
A. 规范与可复制性（最值钱）

Repo 规范：目录结构、命名、组件分层、API 分层（避免越写越乱）

提交/PR 规范：Conventional Commits + PR 模板（让历史像样）

任务流转体系：你那个📂领任务+标记很好，升级成“任务契约”更强（见下）

B. 前后端契约（减少联调痛苦）

API Contract：接口定义一处生效（OpenAPI / tRPC / zod schema → client）

类型贯通：前端直接吃类型（减少“接口改了没人知道”）

C. Supabase 体系化（全栈核心）

RLS 权限模型：表级策略 + 角色（admin/user）+ 组织/租户（如果有）

迁移与种子数据：migration + seed（环境一键复现）

Storage 规则：上传、路径规范、权限策略

Edge Functions（可选）：复杂业务逻辑收口（别全塞前端）

D. 质量与交付（上线后活得久）

CI（必备）：lint + typecheck + test（PR 自动跑）

E2E（必备）：至少覆盖登录→核心功能→后台关键操作

观测（必备）：Sentry + Log（出了问题别靠猜）

灰度/开关（可选）：Feature flag，紧急回滚救命

你那个“📂领任务”的升级版：任务契约（超适合你现在）

每个任务一个文件夹，比如：

/tasks/2026-02-21-admin-role/
  spec.md
  api.md
  ui.md
  done.md

spec.md：一句话目标 + 验收标准（✅列表）

api.md：需要的接口/字段/状态码

ui.md：页面截图/组件清单/交互

done.md：完成记录 + 测试点 + 部署链接

好处：你可以把这个 folder 直接丢给 AI/自己未来的你，都能无痛接手。

Cursor / Claude Code / MCP 在你这套里的“落点”

Cursor Rules：把“项目规范”写死（目录、组件分层、禁止直接改 DB、必须写 RLS 等）

MCP 调度：

读 repo / 读数据库 schema / 查 migration / 查日志

自动生成接口 client、生成 admin CRUD、生成测试用例

并行开发：把任务契约拆成 UI / API / DB / Tests 四块并行跑，然后你做最终合并审查

分支与部署（你现在“维护分支继续”的最简稳妥方案）

推荐你用这个就够了：

main：永远可部署（Vercel Prod）

dev：日常集成（可选）

feat/*：每个任务一支（Vercel Preview 自动起）

合并策略：PR 必须绿灯（CI）+ 有预览链接 + 最少一轮自测清单

如果你愿意下一步更爽，我建议你做一件事就够：
把你现在项目的**“项目规范 + 任务契约模板 + Cursor Rules”**做成一个 starter repo 🧱
以后每开新项目直接复制，不再从0开始重复造轮子。你会发现自己突然变成“能稳定量产的人”。 😏

这样好多了hh，还有我自己还经常在终端如opencode，vscode，cursor中，插件codex，流转，skills适配不同(如有的在.cursor中，有的在系统c盘中)，能否有一个比较统一化的流程呢，避免挪动一次项目要考虑这么多不适配忽略的东西如mcp，skill，规范(比如注意到这些软件有系统rules还是什么的)

可以。你现在的痛点本质是：配置分散在“工具全局 + 项目局部 + 系统某个神秘角落(C盘)”三层，一搬项目就像搬家还得记哪箱里是牙刷😈

下面给你一套统一化方案：目标是做到 “项目走到哪，规则/skills/mcp就跟到哪”，全局只留少量“底座”。

统一化的核心原则（记住这3条就够了）

项目相关的一切，尽量放 repo 里（版本控制、可复制、可回滚）✅

机器相关的一切，放 dotfiles 里（一次配置，全局复用）✅

工具相关的“全局 rules”，只留最小集合（越少越不炸）✅

你要的不是“一个工具统治一切”，而是“一个结构能被所有工具读懂”。🧩

推荐的“三层结构”
① Repo 层（跟项目走）

放：cursor rules、vscode settings、mcp、prompt/skills、脚本、任务流

建议目录长这样：

repo/
  .vscode/
    settings.json
    extensions.json
  .cursor/
    rules/            # Cursor 读
  .ai/
    rules/            # 你自己的“工具无关规则”（单一真源）
    skills/           # 可复用 skill 模块（写成md）
    mcp/              # mcp 配置（json/yaml）
  scripts/
    bootstrap.*       # 一键安装/链接/校验
  Taskfile.yml | justfile | Makefile

关键点：

.ai/ 是你自定义的“统一入口”（Single Source of Truth）。

.cursor/、.vscode/ 这些只是“适配层”，能自动从 .ai/ 同步生成更好。

② Dotfiles 层（跟你走）

放：终端、git、shell、全局最小 rules、通用命令

建议你搞一个 dotfiles 仓库，里面放：

~/.gitconfig / ~/.ssh/config

~/.config/...（尽量走 XDG 风格）

一套通用脚本：dev doctor、dev link、dev update

做法：用 symlink 或工具统一管理（不管你用啥，核心就是“源在 dotfiles，落地是链接”）。

Windows 也行：尽量把“全局配置”放到 %USERPROFILE%\.config\...，然后链接到工具要求的位置，别让 C 盘当你大脑。

③ 工具全局层（越瘦越好）

只放那种 “任何项目都通用” 的规则，比如：

“永远不要提交密钥”

“默认用 Conventional Commits”

“先跑测试再合并”

“回答用中文/简洁风格”

其他一律别放全局。全局一胖，你迟早会被过去的自己背刺🥲

你提到的“skills 不同地方”的统一办法

你现在是：

有的在 .cursor/

有的在系统盘某目录

有的在插件（codex / opencode / claude / vscode）里

统一方案：把“skills 规则内容”都写在 repo 的 .ai/skills/*.md，然后用脚本生成/同步到各工具需要的位置。

最简单可行：一键同步脚本（repo 内）

你只需要保证每个项目里都有一个命令：

./scripts/bootstrap：装依赖 + 链接配置 + 校验

./scripts/doctor：检查 cursor/vscode/mcp 是否都识别到了

这样你换电脑/换目录/换 IDE，只要跑一次 bootstrap 就归位。✅

“MCP、rules、规范”最容易炸的点（提前避雷）
1) MCP 配置别写死绝对路径

用相对路径（相对 repo）

或用环境变量（比如 PROJECT_ROOT）

2) rules 要“分层继承”

.ai/rules/global.md（项目通用）

.ai/rules/frontend.md / backend.md / admin.md（按子域）

.ai/rules/security.md（安全红线）
然后 Cursor/Claude/Codex 各自只引用/同步对应的集合。

3) 工具识别不到？用“适配层”兜底

Cursor 看 .cursor/rules/

VSCode 看 .vscode/

其他工具就让 scripts/ 把 .ai/ 复制/链接到它们的默认路径

给你一套“落地最快”的推荐组合（不纠结工具名）

Repo 内统一入口：.ai/ + scripts/

任务执行器：just / Taskfile / make（选一个，别全要）

环境管理：devcontainer（最省心的跨机一致）或 mise/asdf（轻量）

链接管理：symlink（Windows 用管理员或开发者模式）

你现在就能做的最小改造（1小时内见效😏）

在每个项目加 .ai/（规则/skills/mcp 全塞进去）

加 scripts/bootstrap 和 scripts/doctor

把 Cursor/VSCode 的项目配置都移到 repo（.cursor/、.vscode/）

dotfiles 里只保留“底座”（git/shell/通用禁忌），别塞项目规则

如果你愿意，我可以直接给你一份 “repo 模板目录树 + bootstrap/doctor 伪代码流程 + rules/skills 的文件命名规范”（仍然保持精简），你照抄到一个 starter repo 就能开始量产项目了 ✌️😈

不是，你真会啊，那你展示

行，那我就直接把“统一化模板”端上来 😈✌️
目标：同一个 repo，在 Cursor / VSCode / 终端(opencode)/Codex/Claude/MCP 都能吃到同一套规则。核心是：.ai/ 做单一真源 + scripts 一键同步/校验。

1) 目录模板（直接照抄）
my-app/
  .ai/
    rules/
      00-global.md
      10-frontend.md
      20-backend.md
      30-db-supabase.md
      40-security.md
    skills/
      git-commits.md
      task-contract.md
      api-contract.md
      testing.md
      deployment-vercel.md
    mcp/
      servers.json         # MCP server 定义（相对路径/环境变量）
    manifest.json          # 规则/skills 的“索引”，让脚本知道怎么装配

  .cursor/
    rules/
      README.md            # 由脚本生成（或软链）
  .vscode/
    settings.json
    extensions.json

  scripts/
    bootstrap.sh           # 一键装配（link/copy + deps）
    sync-ai.sh             # 把 .ai 同步到各工具适配层
    doctor.sh              # 检查所有工具配置是否生效

  tasks/
    _template/
      spec.md
      done.md

  justfile (或 Taskfile.yml / Makefile 三选一)
  README.md
2) .ai/manifest.json（单一真源索引）

脚本靠它把规则组合成不同工具需要的形态

{
  "rulesets": {
    "default": [
      ".ai/rules/00-global.md",
      ".ai/rules/40-security.md"
    ],
    "web_fullstack": [
      ".ai/rules/00-global.md",
      ".ai/rules/10-frontend.md",
      ".ai/rules/20-backend.md",
      ".ai/rules/30-db-supabase.md",
      ".ai/rules/40-security.md"
    ]
  },
  "targets": {
    "cursor": {
      "rules_dir": ".cursor/rules",
      "ruleset": "web_fullstack"
    },
    "vscode": {
      "settings": ".vscode/settings.json",
      "extensions": ".vscode/extensions.json"
    },
    "mcp": {
      "config": ".ai/mcp/servers.json"
    }
  }
}
3) .ai/rules/00-global.md（示例：全局工程规则）
# Global Rules

- Prefer small, reviewable diffs.
- Use Conventional Commits: feat/fix/refactor/chore/docs/test/perf/build/ci.
- Do not commit secrets. Use env vars + .env.example.
- Any API change must update contract/types.
- Any DB change must include migration + RLS check (if using Supabase).
- Before merge: typecheck + tests + lint must pass.
4) .ai/rules/30-db-supabase.md（示例：Supabase 规则）
# Supabase Rules

- All tables must have RLS enabled unless explicitly justified.
- Policies must be written for: anon, authenticated, service_role (if used).
- Migrations: keep them deterministic; never edit already-applied migrations.
- Prefer server-side verification for privileged actions (Edge Function).
- Storage buckets require explicit access rules.
5) 任务契约模板（你最常用的📂领任务体系）

tasks/_template/spec.md

# Task Spec

## Goal
- ...

## Acceptance Criteria
- [ ] ...
- [ ] ...

## Scope
- Includes:
- Excludes:

## API/DB Touch?
- API: yes/no
- DB migration: yes/no
- RLS update: yes/no

## Notes
- ...

tasks/_template/done.md

# Done

## What changed
- ...

## Test checklist
- [ ] unit/integration
- [ ] e2e (critical path)
- [ ] preview deployed link verified

## Deploy
- Preview:
- Prod:
6) 同步脚本（核心：把 .ai 输出到 .cursor 等适配层）
scripts/sync-ai.sh
#!/usr/bin/env bash
set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
MANIFEST="$ROOT/.ai/manifest.json"

# tiny helper: read json with python (避免 jq 依赖)
read_json() {
python3 - <<'PY'
import json,sys
path=sys.argv[1]
key=sys.argv[2]
with open(path,'r',encoding='utf-8') as f:
  j=json.load(f)
# key like: targets.cursor.rules_dir
cur=j
for part in key.split('.'):
  cur=cur[part]
print(cur)
PY
}

CURSOR_RULES_DIR=$(read_json "$MANIFEST" "targets.cursor.rules_dir")
RULESET_NAME=$(read_json "$MANIFEST" "targets.cursor.ruleset")

# get files list for ruleset
RULE_FILES=$(python3 - <<PY
import json
m=json.load(open("$MANIFEST","r",encoding="utf-8"))
for p in m["rulesets"]["$RULESET_NAME"]:
  print(p)
PY
)

mkdir -p "$ROOT/$CURSOR_RULES_DIR"

OUT="$ROOT/$CURSOR_RULES_DIR/PROJECT_RULES.md"
echo "# Project Rules (generated)" > "$OUT"
echo "" >> "$OUT"

while IFS= read -r f; do
  echo "" >> "$OUT"
  echo "----" >> "$OUT"
  echo "" >> "$OUT"
  cat "$ROOT/$f" >> "$OUT"
done <<< "$RULE_FILES"

echo "✅ Cursor rules generated at: $CURSOR_RULES_DIR/PROJECT_RULES.md"

这招很狠：Cursor 最终只吃一个 PROJECT_RULES.md，但内容来自 .ai/rules/* 的组合。你换工具、换 IDE 都不怕。

7) 一键安装/链接/初始化
scripts/bootstrap.sh
#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

bash "$ROOT/scripts/sync-ai.sh"

# 可选：检查 node/python 等
command -v node >/dev/null || echo "⚠️ node not found"
command -v python3 >/dev/null || echo "⚠️ python3 not found"

echo "✅ bootstrap done"
8) 检查生效（搬项目后跑它就知道哪缺了）
scripts/doctor.sh
#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

fail=0

check() {
  if [ -e "$1" ]; then
    echo "✅ $2: $1"
  else
    echo "❌ $2 missing: $1"
    fail=1
  fi
}

check "$ROOT/.cursor/rules/PROJECT_RULES.md" "Cursor rules"
check "$ROOT/.vscode/settings.json" "VSCode settings"
check "$ROOT/.ai/mcp/servers.json" "MCP config"
check "$ROOT/.ai/manifest.json" "AI manifest"

if [ "$fail" -eq 1 ]; then
  echo "🚨 doctor failed"
  exit 1
fi

echo "🧠 All good"
9) VSCode 的项目级配置（示例）

.vscode/extensions.json

{
  "recommendations": [
    "esbenp.prettier-vscode",
    "dbaeumer.vscode-eslint"
  ]
}

.vscode/settings.json

{
  "editor.formatOnSave": true,
  "eslint.validate": ["javascript", "typescript", "typescriptreact"],
  "files.eol": "\n"
}
10) 你怎么用（最短路径）

新项目：复制这个模板

每次搬项目/换电脑：

./scripts/bootstrap.sh

./scripts/doctor.sh

你要改规则：只改 .ai/，然后 sync-ai 输出到 Cursor/其他工具

你会得到啥效果？

✅ rules/skills/mcp 不再散落：全在 .ai/

✅ 不同 IDE/插件适配不再靠记忆：脚本统一生成

✅ 项目搬家成本≈0：bootstrap + doctor 两步

你要是想更“无脑”，下一步我会建议你加一个：
Dev Container（把 node/python/supabase cli 全装进容器里），那就是“换电脑也不用装环境”级别的爽。😈